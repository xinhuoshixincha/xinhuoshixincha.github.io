---
layout: post
title:  "Flask开发（一）"
subtitle: "谈谈使用flask_httpauth开发中的大小事"
date:   2021-5-11 21:54:08 +0800
tags: Flask Python 后端
color: rgb(222,243,12)
---

> **前情提要：**由于前后端分离开发涉及到的无状态问题(前端每次请求后端接口都是新建一个会话，很难通过传统的cookie-session方式来实现验证用户登录，存储用户登录状态等功能)，所以考虑了前后端传递token的方式对用户的登录状态进行验证。而为了token的安全性(以及实现的方便性)，我使用了flask-httpauth这个第三方模块来实现用户token验证的功能。==(注意，我这里使用的是此模块的一部分 -- HTTPTokenAuth，如果要使用基本认证请左转出门)==
>
> ***但没想到，这是噩梦的开端***

## 初步使用flask-httpauth

当考虑使用第三方模块的时候，我的第一动作就是去观摩一下前人的使用方式。我很幸运，成功的找到了关于flask-httpauth的教程案例。

### 首先，是万能第一步

在你项目目录下的命令行(虚拟环境也一样)中敲入这句

```
pip install flask-httpauth
```

这样，flask-httpauth就被装到了你的项目环境中

### 接下来，找到你要用到这个模块的python文件

```python
# 引入头文件
from flask_httpauth import HTTPTokenAuth
# 引入istdangerous模块中的TimedJSONWebSignatureSerializer类用来生成一个具有过期时间的token
# BadSignature是一个异常，当token错误的时候会抛出此异常
# SignatureExpored是一个异常，当token过期的时候会抛出此异常
from itsdangerous import TimedJSONWebSignatureSerializer, BadSignature, SignatureExpired

# 初始化HTTPTokenAuth对象。传入的scheme表示前缀，具体什么作用稍后再说
auth = HTTPTokenAuth(scheme="DAHU")

# 写一个获取token的函数，使用的是API形式，方便测试时获取
@app.route('/api/test-http-auth-token/token', methods=["GET"])
def get_token():
    # 创建一个TimedJSONWebSignatureSerializer对象
    # 第一个参数是随便一串字符串
    # 第二个参数设定过期时间，单位为秒,比如我这里设定的就是1分钟过期(方便测试能否正常捕获token过期异常)
    s1 = TimedJSONWebSignatureSerializer("DAHUBIGFOXSHABI", expires_in=60)
    # 将userId作为数据装到token中，方便我们之后校验用户
    # 默认s1.dumps执行完后返回的是byte格式，但我们需要的是字符串格式，所以用decode函数对结果解码得到token字符串
    token = s1.dumps({"userId": 1}).decode('ascii')
    # 返回json格式的token
    return jsonify(Authorization=token)

# 你可以在这个装饰器下面的函数内实现你自己的token验证方法
@auth.verify_token
def verify_token(token):
    """验证token
		
        :param token: 要验证的token
    """
    # 创建TimedJSONWebSignatureSerializer，传入一个参数，就是前文中那一串字符串(要和前文一样)
    s = TimedJSONWebSignatureSerializer("DAHUBIGFOXSHABI")
    try:
        print(token)
        # 解析token,获取数据(也就是咱们之前包装在token中的{"userId":1})
        data = s.loads(token)
        print(data)
    except SignatureExpired:
        print("token过期")
        return False
    except BadSignature:
        print("token错误")
        return False
    uid = data['userId']
    print(uid)
    return True

@app.route('/api/test-http-auth-token/token', methods=["POST"])
# 加了这条语句就表示要访问此路由需要进行token认证
@auth.login_required
def verify_token():
    return jsonify(code=200)
```

> 以上代码还有一点是需要注意的: 捕捉SignatureExpired异常和捕捉BadSignature异常的顺序是不可以颠倒的，因为在源程序中SignatureExpired类的继承顺序是这样的: SignatureExpired继承于BadTimeSignature， BadTimeSignature继承于BadSignature。
>
> 显而易见，SignatureExpired是BadSignature的子孙类，如果先捕获BadSignature异常的话，SignatureExpired也会被作为BadSignature异常被捕获，也就不能精确的获取token过期的错误消息了。

#### 接口全部书写完毕，接下来就是紧张刺激的测试环节了

我使用的测试接口的工具是ApiPost, 具体操作我就不赘述了，我创建了两个接口测试用例

1. 第一个是获取token, 也就是对应着刚刚写的代码中的get_token函数
2. 第二个是验证token, 也就是对应着刚刚写的代码中的verify_token函数

**首先把flask运行起来**

**然后获取token**，对接口发送请求后会返回这么一条json数据

<img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-224756-0576.png" alt="get_token返回的数据" style="zoom:100%;" align="left"/>

Authorization对应的字符串就是我们需要的token

**最后就是验证token了**，将Authorization作为请求头，如下

<img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-232809-0868.png" alt="验证token的请求头示例" style="zoom:100%;" align="left"/>

```
  Authorization:DAHU eyJhbGciOiJIUzUx...
```

发送请求后会有三种情况

1. 认证成功

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-231717-0262.png" align="left">

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-231518-0877.png" align="left">

2. token错误

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-233019-0110.png" align="left">

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-230020-0610.png" align="left">

3. token过期

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-233821-0242.png" align="left">

   <img src="https://gitee.com/xinhuoshixincha/PictureBed/raw/master/blog/flask-httpauth/20210511-230020-0610.png" align="left">

这样，token验证就基本完成了

